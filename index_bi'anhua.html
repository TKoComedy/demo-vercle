<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>彼岸花 · 动态页</title>
  <style>
    /* 页面基础样式 */
    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 800px at 70% 20%, #0b0f1a 0%, #070913 35%, #05060c 70%, #03040a 100%);
      overflow: hidden;
      color: #f6e7f1;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "PingFang SC", "Microsoft YaHei", sans-serif;
    }
    .wrap {
      position: fixed;
      inset: 0;
    }
    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      filter: drop-shadow(0 0 10px rgba(255, 120, 180, .4));
    }
    .ui {
      position: absolute;
      left: 50%;
      bottom: 32px;
      transform: translateX(-50%);
      text-align: center;
      line-height: 1.6;
      user-select: none;
      pointer-events: none;
    }
    .ui h1 {
      margin: 0 0 6px 0;
      font-size: clamp(18px, 3.6vw, 28px);
      letter-spacing: .2em;
      font-weight: 600;
      text-shadow: 0 0 12px rgba(255, 150, 200, .35);
    }
    .ui .hint { opacity: .8; font-size: 12px; }

    /* 轻微星光 */
    .stars::before, .stars::after {
      content: "";
      position: absolute;
      inset: 0;
      background-image: radial-gradient(2px 2px at 10% 20%, rgba(255,255,255,.6) 0, transparent 50%),
                        radial-gradient(1px 1px at 80% 35%, rgba(255,255,255,.45) 0, transparent 50%),
                        radial-gradient(1.5px 1.5px at 30% 70%, rgba(255,255,255,.5) 0, transparent 50%),
                        radial-gradient(1px 1px at 60% 15%, rgba(255,255,255,.35) 0, transparent 50%),
                        radial-gradient(1.2px 1.2px at 90% 80%, rgba(255,255,255,.35) 0, transparent 50%);
      opacity: .35;
      pointer-events: none;
      animation: twinkle 8s linear infinite;
    }
    .stars::after { animation-duration: 11s; opacity: .25; }
    @keyframes twinkle { 0%{transform:translateY(0)} 100%{transform:translateY(-10px)} }
  </style>
</head>
<body>
  <div class="wrap stars">
    <canvas id="scene"></canvas>
  </div>
  <div class="ui">
    <h1>彼岸花</h1>
    <div class="hint">点击/拖拽可生成花瓣 · Scroll 改变大小</div>
  </div>

  <script>
    // 基于 Canvas 的彼岸花与花瓣飘落效果
    (function () {
      const canvas = document.getElementById('scene');
      const ctx = canvas.getContext('2d');

      const DPR = Math.min(2, window.devicePixelRatio || 1);
      let width = 0; let height = 0; let cx = 0; let cy = 0;

      function resize() {
        width = canvas.clientWidth;
        height = canvas.clientHeight;
        canvas.width = Math.floor(width * DPR);
        canvas.height = Math.floor(height * DPR);
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        cx = width / 2; cy = height * 0.62;
      }
      resize();
      addEventListener('resize', resize);

      // 参数控制
      let baseRadius = Math.min(width, height) * 0.22;
      let scale = 1;
      addEventListener('wheel', (e) => {
        const delta = Math.sign(e.deltaY);
        scale = Math.max(.5, Math.min(1.8, scale - delta * 0.05));
      }, { passive: true });

      // 花瓣飘落粒子
      const petals = [];
      const PETAL_COLORS = [
        'rgba(255, 60, 110, .95)',
        'rgba(255, 95, 140, .9)',
        'rgba(255, 130, 170, .85)'
      ];

      function spawnPetal(x = Math.random() * width, y = -20, burst = false) {
        const size = 6 + Math.random() * 10;
        petals.push({
          x, y,
          vx: (-.6 + Math.random() * 1.2) + (burst ? (Math.random() - .5) * 2 : 0),
          vy: 0.6 + Math.random() * 1.1 + (burst ? Math.random() * .6 : 0),
          rot: Math.random() * Math.PI * 2,
          vr: (-.03 + Math.random() * .06),
          size,
          color: PETAL_COLORS[(Math.random() * PETAL_COLORS.length) | 0],
          life: 0,
          maxLife: 7 + Math.random() * 7
        });
      }

      for (let i = 0; i < 60; i++) spawnPetal(Math.random() * width, Math.random() * height);

      canvas.addEventListener('pointerdown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        for (let i = 0; i < 18; i++) spawnPetal(mx, my, true);
      });
      canvas.addEventListener('pointermove', (e) => {
        if (e.buttons !== 1) return;
        const rect = canvas.getBoundingClientRect();
        spawnPetal(e.clientX - rect.left, e.clientY - rect.top, true);
      });

      // 绘制单个花瓣（彼岸花细长卷须状）
      function drawSpiderLilyPetal(angle, radius, t) {
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(angle);
        ctx.scale(scale, scale);

        const length = radius * (1.2 + 0.07 * Math.sin(t * 1.6));
        const curl = 0.55 + 0.25 * Math.sin(t + angle * 2);
        const thickness = 3.2;

        // 发光渐变
        const grd = ctx.createLinearGradient(0, 0, length, 0);
        grd.addColorStop(0, 'rgba(255,130,170,.05)');
        grd.addColorStop(.25, 'rgba(255,120,180,.45)');
        grd.addColorStop(.8, 'rgba(255,160,210,.7)');
        grd.addColorStop(1, 'rgba(255,220,235,.3)');

        ctx.lineWidth = thickness;
        ctx.strokeStyle = grd;
        ctx.beginPath();
        ctx.moveTo(0, 0);

        // 主体：多段贝塞尔制造细长与卷曲
        const p1x = length * 0.35, p1y = -radius * 0.25;
        const p2x = length * 0.75, p2y = radius * 0.18 * curl;
        const p3x = length, p3y = -radius * 0.05 * (1 + curl);
        ctx.bezierCurveTo(p1x, p1y, p2x, p2y, p3x, p3y);
        ctx.stroke();

        // 顶端回钩
        ctx.lineWidth = 2.2;
        ctx.beginPath();
        ctx.moveTo(p3x, p3y);
        ctx.quadraticCurveTo(length * 0.85, p3y - radius * 0.18, length * 0.7, p3y + radius * 0.06);
        ctx.stroke();

        // 細蕊光点
        ctx.fillStyle = 'rgba(255, 190, 220, .7)';
        for (let k = 0; k < 3; k++) {
          const px = length * (0.55 + k * 0.12);
          const py = p3y * (0.2 + k * 0.35);
          ctx.beginPath();
          ctx.arc(px, py, 1.6 + (k === 2 ? 1.4 : 0), 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.restore();
      }

      function drawCoreGlow(radius, t) {
        const r = radius * scale;
        const pulse = 0.5 + 0.5 * Math.sin(t * 1.2);
        const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, r * 1.4);
        grd.addColorStop(0, `rgba(255,120,160, ${0.25 + pulse * 0.15})`);
        grd.addColorStop(0.5, 'rgba(255,70,120, .15)');
        grd.addColorStop(1, 'rgba(255,50,110, 0)');
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(cx, cy, r * 1.4, 0, Math.PI * 2);
        ctx.fill();
      }

      function drawStem(radius) {
        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(scale, scale);
        const grd = ctx.createLinearGradient(0, 0, 0, radius * 2.2);
        grd.addColorStop(0, 'rgba(90,210,160,.6)');
        grd.addColorStop(1, 'rgba(30,120,90,.0)');
        ctx.strokeStyle = grd;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.bezierCurveTo(-radius * 0.08, radius * 0.35, radius * 0.05, radius * 1.1, 0, radius * 2);
        ctx.stroke();
        ctx.restore();
      }

      // 动画主循环
      let start = performance.now();
      function animate(now) {
        const t = (now - start) / 1000;
        ctx.clearRect(0, 0, width, height);

        // 背景水雾亮纹
        ctx.save();
        const bg = ctx.createLinearGradient(0, 0, 0, height);
        bg.addColorStop(0, 'rgba(255, 120, 170, .06)');
        bg.addColorStop(1, 'rgba(120, 150, 255, .03)');
        ctx.fillStyle = bg;
        ctx.fillRect(0, height * .78, width, height * .22);
        ctx.restore();

        // 彼岸花主体
        const radius = baseRadius * (1 + 0.03 * Math.sin(t));
        drawCoreGlow(radius, t);
        drawStem(radius);
        const petalsCount = 16;
        for (let i = 0; i < petalsCount; i++) {
          const ang = (i / petalsCount) * Math.PI * 2 + Math.sin(t * .6) * 0.05;
          drawSpiderLilyPetal(ang, radius, t + i * 0.2);
        }

        // 落花粒子层
        for (let i = petals.length - 1; i >= 0; i--) {
          const p = petals[i];
          p.life += 1/60;
          p.vx += Math.sin(t * .7 + p.y * .01) * 0.005;
          p.x += p.vx * (1 + 0.4 * Math.sin(p.life * 3));
          p.y += p.vy;
          p.rot += p.vr;

          // 绘制花瓣（心形片状）
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot);
          const s = p.size * (0.9 + 0.1 * Math.sin(p.life * 5));
          const grd = ctx.createRadialGradient(0, 0, 0, 0, 0, s * 1.2);
          grd.addColorStop(0, 'rgba(255,255,255,.7)');
          grd.addColorStop(0.35, p.color);
          grd.addColorStop(1, 'rgba(255,0,70,0)');
          ctx.fillStyle = grd;
          ctx.beginPath();
          ctx.moveTo(0, -s * .3);
          ctx.bezierCurveTo(s * .8, -s * 1.1, s * 1.1, s * .4, 0, s);
          ctx.bezierCurveTo(-s * 1.1, s * .4, -s * .8, -s * 1.1, 0, -s * .3);
          ctx.fill();
          ctx.restore();

          if (p.y > height + 30 || p.life > p.maxLife) {
            petals.splice(i, 1);
            spawnPetal(Math.random() * width, -20);
          }
        }

        requestAnimationFrame(animate);
      }
      requestAnimationFrame(animate);
    })();
  </script>
</body>
</html>


